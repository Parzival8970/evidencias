{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":""},{"location":"#bienvenido","title":"Bienvenido","text":"<p>Este es mi portafolio de evidencias para mis clases de sistemas embebidos 1 y proyecto de ingenieria IV, ambas de mi carrea de Ing. Mecatr\u00f3nica</p>"},{"location":"#sobre-mi","title":"Sobre mi","text":"<p>Mi nombre es Rodrigo Miranda Flores, aqu\u00ed encontraras mi documentaci\u00f3n sobre mis proyectos, ejercicios de clase y tareas con una breve explicaci\u00f3n, evidencias esperando te agrade y te sirva un poco.</p>"},{"location":"#contacto","title":"Contacto","text":"<ul> <li>Correo electronico: 199304@iberopuebla.mx</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%201/","title":"\ud83d\udcda Semana 1","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%201/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Estacionamiento Sustentable </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: En este apartado mostrar\u00e9 los avances sobre nuestro proyecto de un estacionamiento sustentable.</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%201/#2-objetivo","title":"2) Objetivo","text":"<ul> <li>General: la optimizaci\u00f3n en la rotaci\u00f3n de veh\u00edculos, organizaci\u00f3n del flujo de tr\u00e1nsito y mejoramiento de la circulaci\u00f3n en \u00e1reas urbanas.</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%201/#presentacion","title":"Presentaci\u00f3n","text":"<p>Descargar PDF</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/","title":"\ud83d\udcda Semana 3","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Estacionamiento Sustentable </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 12/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra la tarea de el proyecto \"caf\u00e9 en c\u00e1psula\".</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#historia-del-cafe-en-capsula","title":"Historia del caf\u00e9 en c\u00e1psula","text":"<p>El origen del caf\u00e9 expreso se remonta a principios del siglo XX en Italia. En 1901, Luigi Bezzera, desarroll\u00f3 un sistema para acelerar la preparaci\u00f3n del caf\u00e9 al incorporar vapor a presi\u00f3n en la cafetera. Este procedimiento no solo reduc\u00eda el tiempo de preparaci\u00f3n, sino que tambi\u00e9n produc\u00eda una bebida m\u00e1s concentrada y densa, pero no logr\u00f3 posicionar comercialmente su invento.</p> <p>En 1905, Desiderio Pavoni adquiri\u00f3 la patente de Bezzera. Con visi\u00f3n empresarial, introdujo la m\u00e1quina de expreso en el mercado italiano. Posteriormente, el desarrollo tecnol\u00f3gico continu\u00f3 en 1938, con Cremonesi, quien dise\u00f1\u00f3 una cafetera de pist\u00f3n que eliminaba el regusto a quemado derivado del uso de vapor o agua en ebullici\u00f3n y Achille Gaggia quien perfeccion\u00f3 la t\u00e9cnica al incorporar un pist\u00f3n de muelle que permit\u00eda aplicar presi\u00f3n al agua sin depender de la caldera de vapor. </p> <p>En 1961, la empresa Faema introdujo una innovaci\u00f3n clave: la m\u00e1quina de bomba el\u00e9ctrica. Este sistema hac\u00eda pasar agua a presi\u00f3n a trav\u00e9s del caf\u00e9, lo que dio origen al modelo de cafeteras de bomba, antecesoras directas de las cafeteras expreso modernas. Hacia mediados de la d\u00e9cada de 1970, el caf\u00e9 instant\u00e1neo gozaba de gran popularidad. En este contexto, el ingeniero suizo \u00c9ric Favre plante\u00f3 un nuevo desaf\u00edo: permitir que cualquier persona pudiera preparar en su hogar un expreso de calidad comparable al servido en cafeter\u00edas italianas. Favre trabaj\u00f3 en un sistema de c\u00e1psulas que denomin\u00f3 \u201cc\u00e9lula de extracci\u00f3n\u201d, cuyo dise\u00f1o concentraba los sabores y aromas del caf\u00e9. Su soluci\u00f3n t\u00e9cnica consisti\u00f3 inicialmente en una media esfera con un filtro y una membrana en la base. Posteriormente, modific\u00f3 el dise\u00f1o de manera que toda la c\u00e1psula actuara como filtro.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#avances-tecnologicos-y-diseno","title":"Avances tecnol\u00f3gicos y dise\u00f1o","text":"<p>Inicialmente las c\u00e1psulas de aluminio en su dise\u00f1o original (1995), pesaban 2 gramos con un contenido de caf\u00e9 de 3 gramos.Ten\u00eda una forma de media esfera y una base con filtro, dise\u00f1o que aun se usa en algunos modelos de c\u00e1psula en la actualidad.</p> <p>Favre tambi\u00e9n desarroll\u00f3 un envase para la c\u00e1psula con un dise\u00f1o de alta eficiencia. Este se compone de siete capas de polipropileno, lo que garantiza la conservaci\u00f3n del caf\u00e9 al tiempo que reduce la proporci\u00f3n de material de embalaje. El envoltorio representa solo el 12% del peso total de la c\u00e1psula, siendo el resto caf\u00e9.</p> <p>El resultado fue el sistema Monodor, que marc\u00f3 un hito en la preparaci\u00f3n dom\u00e9stica de caf\u00e9 expreso. Dado el potencial comercial de esta innovaci\u00f3n, Favre y su empresa, Monodor S.A., establecieron una s\u00f3lida estrategia de protecci\u00f3n de patentes para asegurar la exclusividad de su tecnolog\u00eda.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#nestle-estrategia","title":"Nestl\u00e9 estrategia","text":"<p>Nestl\u00e9 entr\u00f3 en este mercado con su empresa de caafeteras Nesspreso con un un inicio poco favorable. Sin embargo gracias a su estrategia de marketing con una experiencia explusiva para los consumidores, la patente sali\u00f3 a flote.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#presentacion","title":"Presentaci\u00f3n","text":"<p>Descargar PDF</p>"},{"location":"Sistemas%20embebidos/Tarea%201/","title":"\ud83d\udcda Tarea 1","text":""},{"location":"Sistemas%20embebidos/Tarea%201/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Tabla comparativa de microcontroladores </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra un cuadro comparativo sobre microcontroladores elegidos por mi, mencionando cuales me parecen mejores, cuales usar\u00eda y porque.</li> </ul> <p>1) Cuadro comparativo</p> <p></p> <p>Elej\u00ed estos microcontroladores porque conozco a algunos y porque quise variar sus caracteristicas para compararlos mejor y no con uno muy similar.</p> <p>En mi opini\u00f3n me gusta mas el ESP32 por sus perifericos, en segundo lugar pondria al ATmega328P por su uso en arduino ya conocido, en tercero seria RP2040 por la IA pero espero conocerlo m\u00e1s con posibilidad de subirlo de nviel, en cuarto dejo ap TI MSP430 porque no eh tenido la oportunidad de usarlo.</p> <p>Para mi proyecto usaria este orden RP2040, ESP32, ATmega328P y al ultimo igualmente el TI MSP430.</p>"},{"location":"Sistemas%20embebidos/Tarea%202/","title":"\ud83d\udcda Tarea 2","text":""},{"location":"Sistemas%20embebidos/Tarea%202/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Outputs Basicos </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 27/08/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 3 ejercicios un Contador binario 4 bits, un barrido de 5 leds y una secuencia en codigo Gray.</li> </ul>"},{"location":"Sistemas%20embebidos/Tarea%202/#contador-binario-de-4-bits","title":"Contador binario de 4 bits","text":"<p>1) Que debe hacer: En cuatro leds debe mostrarse cad segundo la representacion binaria del 0 al 15</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#define A   0\n#define B   1\n#define C   2\n#define D   3\n\nint main() {\n   const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D);\n   gpio_init_mask(MASK);\n   gpio_set_dir_masked(MASK, MASK);  \n   while (true) {\n       for (uint8_t i = 0; i &lt; 16; i++) {\n           gpio_put_masked(MASK, i &lt;&lt; A);\n           sleep_ms(500);                \n       }\n   }\n}\n</code></pre></p> <p>3) Esquematico de conexi\u00f3n: </p> <p>4) Video: Video en Youtube</p>"},{"location":"Sistemas%20embebidos/Tarea%202/#barrido-de-5-leds","title":"Barrido de 5 Leds","text":"<p>1) Que debe hacer: Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</p> <p>2) Codigo: <pre><code>#include \"pico/stdli-b.h\"\n#include \"hardware/gpio.h\"\n#define A 0  \n#define B 1  \n#define C 2  \n#define D 3\n#define E 4  \nint main() {\n   const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D) | (1u&lt;&lt;E);\n   gpio_init_mask(MASK);\n   gpio_set_dir_out_masked(MASK);  \n   gpio_clr_mask(MASK);            \n   while (true) {\n       for (int i = 0; i &lt; 5; ++i) {\n           gpio_clr_mask(MASK);                \n           gpio_set_mask(1 &lt;&lt; i);              \n           sleep_ms(300);\n       }\n       for (int i = 3; i &gt; 0; --i) {\n           gpio_clr_mask(MASK);\n           gpio_set_mask(1 &lt;&lt; i);\n           sleep_ms(300);\n       }\n   }\n}\n</code></pre></p> <p>3) Esquematico de conexi\u00f3n: </p> <p>4) Video: Video en Youtube</p>"},{"location":"Sistemas%20embebidos/Tarea%202/#secuencia-en-codigo-gray","title":"Secuencia en codigo Gray","text":"<p>1) Que debe hacer: En cuatro leds debe mostrarse cad segundo la representacion en codigo Gray del 0 al 15</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#define A 0\n#define B 1\n#define C 2\nuint8_t bin_gray(uint8_t num_dec) {\n   return num_dec ^ (num_dec &gt;&gt; 1);\n}\nint main() {\n   const uint8_t MASK = (1u &lt;&lt; A) | (1u &lt;&lt; B) | (1u &lt;&lt; C);\n   gpio_init_mask(MASK);\n   gpio_set_dir_masked(MASK, MASK);\n   while (true) {\n       for (uint8_t i = 0; i &lt; 8; i++) {\n           uint8_t gray = bin_gray(i);\n           gpio_put_masked(MASK, gray);\n           sleep_ms(500);\n       }\n   }\n}\n</code></pre></p> <p>3) Esquematico de conexi\u00f3n: </p> <p>4) Video: Video en Youtube</p>"},{"location":"Sistemas%20embebidos/Tarea%203/","title":"\ud83d\udcda Tarea 3","text":""},{"location":"Sistemas%20embebidos/Tarea%203/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Inputs </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 01/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran  2 ejercicios 3 compuertas b\u00e1sicas AND / OR / XOR con 2 botones y un selector c\u00edclico de 4 LEDs con avance/retroceso.</li> </ul>"},{"location":"Sistemas%20embebidos/Tarea%203/#3-compuertas-basicas-and-or-xor-con-2-botones","title":"3 compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<p>1) Que debe hacer: Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <p>2) Codigo: Codigo de compuerta AND <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_AND 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A);\n    gpio_set_dir(BTN_A, false);\n    gpio_pull_up(BTN_A);\n\n    gpio_init(BTN_B);\n    gpio_set_dir(BTN_B, false);\n    gpio_pull_up(BTN_B);\n\n    gpio_init(LED_AND);\n    gpio_set_dir(LED_AND, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a &amp;&amp; b;\n\n        gpio_put(LED_AND, result);\n\n        sleep_ms(50);\n    }\n}\n</code></pre></p> <p>Codigo: Codigo de compuerta OR <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_OR 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A); gpio_set_dir(BTN_A, false); gpio_pull_up(BTN_A);\n    gpio_init(BTN_B); gpio_set_dir(BTN_B, false); gpio_pull_up(BTN_B);\n\n    gpio_init(LED_OR); gpio_set_dir(LED_OR, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a || b;\n\n        gpio_put(LED_OR, result);\n        sleep_ms(50);\n    }\n}\n</code></pre> Codigo: Codigo de compuerta XOR <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_XOR 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A); gpio_set_dir(BTN_A, false); gpio_pull_up(BTN_A);\n    gpio_init(BTN_B); gpio_set_dir(BTN_B, false); gpio_pull_up(BTN_B);\n\n    gpio_init(LED_XOR); gpio_set_dir(LED_XOR, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a ^ b;\n\n        gpio_put(LED_XOR, result);\n        sleep_ms(50);\n    }\n}\n</code></pre> 3) Esquematico de conexion: Se us\u00f3 el mismo circuito para las 3 compuertas </p> <p>4) Video:</p> <p>Compuerta AND</p> <p>Compuerta OR</p> <p>Compuerta XOR</p>"},{"location":"Sistemas%20embebidos/Tarea%203/#selector-ciclico-de-4-leds-con-avanceretroceso","title":"Selector c\u00edclico de 4 LEDs con avance/retroceso","text":"<p>1) Que debe hacer: Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n\n#define BTN_PREV 0      \n#define BTN_NEXT 1    \n#define LED0   2\n#define LED1   3\n#define LED2   4\n#define LED3   5\n\nuint8_t STATE = LED0 - 1;\n\nint main(void) {\n    const uint8_t LEDs_M = (1u &lt;&lt; LED0 | 1u &lt;&lt; LED1 | 1u &lt;&lt; LED2 | 1u &lt;&lt; LED3);\n\n    gpio_init_mask(LEDs_M);\n    gpio_set_dir_out_masked(LEDs_M);\n    gpio_set_mask(LEDs_M);   \n    gpio_clr_mask(LEDs_M);\n\n    gpio_init(BTN_PREV);\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    gpio_init(BTN_NEXT);\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    bool NEXT_PREVSTATE = 1;\n    bool PREV_PREVSTATE = 1;\n\n    while (true) {\n        bool NEXT_STATE = !gpio_get(BTN_NEXT);\n        bool PREV_STATE = !gpio_get(BTN_PREV);\n\n        if (NEXT_STATE &amp;&amp; !NEXT_PREVSTATE) {\n            if (STATE == LED3) {\n                STATE = LED0;\n            } else {\n                STATE ++;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        if (PREV_STATE &amp;&amp; !PREV_PREVSTATE) {\n            if (STATE == LED0) {\n                STATE = LED3;\n            } else {\n                STATE --;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        NEXT_PREVSTATE = NEXT_STATE;\n        PREV_PREVSTATE = PREV_STATE;\n\n        sleep_ms(10);\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video: Video en youtube</p>"},{"location":"Sistemas%20embebidos/Tarea%204/","title":"\ud83d\udcda Tarea 4","text":""},{"location":"Sistemas%20embebidos/Tarea%204/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Led Pong </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 04/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra el juego \"Led Pong\" hecho con una raspberry Pico 2.</li> </ul>"},{"location":"Sistemas%20embebidos/Tarea%204/#led-pong","title":"LED PONG","text":"<p>1) Que debe hacer: Se trara de un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p> <p>2) Reglas del juego</p> <p>1) Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> <p>2) Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <ul> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> </ul> <p>3) Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> <p>4) Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> <p>5) Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> <p>6) Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> <p>3) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_P1 0\n#define L1     1\n#define L2     2\n#define L3     3\n#define L4     4\n#define L5     5\n#define LED_P2 6\n\n#define BTN_L  7\n#define BTN_R  8\n\nvolatile bool golpe_L = false;\nvolatile bool golpe_R = false;\nint pos = L3;\nint dir = 0;\n\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN_L) {\n        if (pos == L1) golpe_L = true;\n        else if (dir == 0) dir = 1;\n    }\n    else if (gpio == BTN_R) {\n        if (pos == L5) golpe_R = true;\n        else if (dir == 0) dir = -1;\n    }\n}\n\nvoid parpadear_led(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid reiniciar_juego(int ganador) {\n    parpadear_led(ganador);\n    pos = L3;\n    gpio_put(L3, 1);\n\n    if (ganador == LED_P2) {\n        dir = 1;\n    } else if (ganador == LED_P1) {\n        dir = -1;\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint32_t MASK = (1u&lt;&lt;LED_P1)|(1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5)|(1u&lt;&lt;LED_P2);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    gpio_init(BTN_L); gpio_set_dir(BTN_L, false); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R, false); gpio_pull_up(BTN_R);\n\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    int pos_anterior = L3;\n    gpio_put(pos_anterior, 1);\n\n    while (true) {\n\n        gpio_put(pos_anterior, 0);\n        gpio_put(pos, 1);\n        pos_anterior = pos;\n\n        sleep_ms(500);\n\n        if (dir == 0) continue;\n\n        if (pos == L1) {\n            if (golpe_L) {\n                dir = 1;\n                golpe_L = false;\n            } else {\n                reiniciar_juego(LED_P2);\n                continue;\n            }\n        } else if (pos == L5) {\n            if (golpe_R) {\n                dir = -1;\n                golpe_R = false;\n            } else {\n                reiniciar_juego(LED_P1);\n                continue;\n            }\n        }\n\n        if (pos == L2 &amp;&amp; golpe_L) {\n            dir = 1;\n            golpe_L = false;\n        } else if (pos == L4 &amp;&amp; golpe_R) {\n            dir = -1;\n            golpe_R = false;\n        }\n\n        pos += dir;\n    }\n}\n</code></pre></p> <p>4) Esquematico de conexion: </p> <p>5) Video:</p> <p>Video en youtube</p>"},{"location":"Sistemas%20embebidos/Tarea%205/","title":"\ud83d\udcda Tarea 5","text":""},{"location":"Sistemas%20embebidos/Tarea%205/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Ejercicios de medicion </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 15/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 2 ejercicios de medici\u00f3n con osciloscopio.</li> </ul>"},{"location":"Sistemas%20embebidos/Tarea%205/#ejercicio-1-medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"(Ejercicio 1) Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>1) Que debe hacer: Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio: - Periodo promedio y tolerancia. - Jitter pico-a-pico y, si tu equipo lo permite, RMS. - Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s)..</p> <p>2) Codigo: <pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     1  // usaremos la alarma 1\n\n// Calcula el n\u00famero de IRQ para esa alarma\n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 100000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Muestras de la medic\u00f3n</p> <p>5) Video:</p> <p>Video en youtube</p>"},{"location":"Sistemas%20embebidos/Tarea%205/#ejercicio-2-comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"(Ejercicio 2) Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>1) Que debe hacer: _Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <ul> <li>Usa rearme acumulativo.</li> <li>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico. Con el osciloscopio, mide y registra para cada modo:</li> <li>Periodo promedio y desviaci\u00f3n respecto al nominal.</li> <li>Jitter pico-a-pico y/o RMS.</li> <li>Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.(mantener modo \u00b5s).._</li> </ul> <p>2) Codigo: <pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     1  // usaremos la alarma 1\n\n// Calcula el n\u00famero de IRQ para esa alarma\n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 100000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Muestras de la medic\u00f3n</p> <p>5) Video:</p> <p>Video en youtube</p>"},{"location":"Sistemas%20embebidos/Tarea%206/","title":"\ud83d\udcda Tarea 6","text":""},{"location":"Sistemas%20embebidos/Tarea%206/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Ejercicios de medicion </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 17/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra una actualizaci\u00f3n del juego \"Led Pong\".</li> </ul>"},{"location":"Sistemas%20embebidos/Tarea%206/#ejercicio-1","title":"Ejercicio 1","text":"<p>1) Que debe hacer: Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. .</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_P1 0\n#define L1     1\n#define L2     2\n#define L3     3\n#define L4     4\n#define L5     5\n#define LED_P2 6\n\n#define BTN_L  7\n#define BTN_R  8\n\nvolatile bool golpe_L = false;\nvolatile bool golpe_R = false;\nint pos = L3;\nint dir = 0;\n\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN_L) {\n        if (pos == L1) golpe_L = true;\n        else if (dir == 0) dir = 1;\n    }\n    else if (gpio == BTN_R) {\n        if (pos == L5) golpe_R = true;\n        else if (dir == 0) dir = -1;\n    }\n}\n\nvoid parpadear_led(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid reiniciar_juego(int ganador) {\n    parpadear_led(ganador);\n    pos = L3;\n    gpio_put(L3, 1);\n\n    if (ganador == LED_P2) {\n        dir = 1;\n    } else if (ganador == LED_P1) {\n        dir = -1;\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint32_t MASK = (1u&lt;&lt;LED_P1)|(1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5)|(1u&lt;&lt;LED_P2);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    gpio_init(BTN_L); gpio_set_dir(BTN_L, false); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R, false); gpio_pull_up(BTN_R);\n\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    int pos_anterior = L3;\n    gpio_put(pos_anterior, 1);\n\n    while (true) {\n\n        gpio_put(pos_anterior, 0);\n        gpio_put(pos, 1);\n        pos_anterior = pos;\n\n        sleep_ms(500);\n\n        if (dir == 0) continue;\n\n        if (pos == L1) {\n            if (golpe_L) {\n                dir = 1;\n                golpe_L = false;\n            } else {\n                reiniciar_juego(LED_P2);\n                continue;\n            }\n        } else if (pos == L5) {\n            if (golpe_R) {\n                dir = -1;\n                golpe_R = false;\n            } else {\n                reiniciar_juego(LED_P1);\n                continue;\n            }\n        }\n\n        if (pos == L2 &amp;&amp; golpe_L) {\n            dir = 1;\n            golpe_L = false;\n        } else if (pos == L4 &amp;&amp; golpe_R) {\n            dir = -1;\n            golpe_R = false;\n        }\n\n        pos += dir;\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p> <p>Video en youtube</p>"},{"location":"Sistemas%20embebidos/Tarea%206/#ejercicio-2","title":"Ejercicio 2","text":"<p>1) Que debe hacer: Modificar su pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_P1 0\n#define L1     1\n#define L2     2\n#define L3     3\n#define L4     4\n#define L5     5\n#define LED_P2 6\n\n#define BTN_L  7\n#define BTN_R  8\n\nvolatile bool golpe_L = false;\nvolatile bool golpe_R = false;\nint pos = L3;\nint dir = 0;\n\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN_L) {\n        if (pos == L1) golpe_L = true;\n        else if (dir == 0) dir = 1;\n    }\n    else if (gpio == BTN_R) {\n        if (pos == L5) golpe_R = true;\n        else if (dir == 0) dir = -1;\n    }\n}\n\nvoid parpadear_led(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid reiniciar_juego(int ganador) {\n    parpadear_led(ganador);\n    pos = L3;\n    gpio_put(L3, 1);\n\n    if (ganador == LED_P2) {\n        dir = 1;\n    } else if (ganador == LED_P1) {\n        dir = -1;\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint32_t MASK = (1u&lt;&lt;LED_P1)|(1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5)|(1u&lt;&lt;LED_P2);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    gpio_init(BTN_L); gpio_set_dir(BTN_L, false); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R, false); gpio_pull_up(BTN_R);\n\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    int pos_anterior = L3;\n    gpio_put(pos_anterior, 1);\n\n    while (true) {\n\n        gpio_put(pos_anterior, 0);\n        gpio_put(pos, 1);\n        pos_anterior = pos;\n\n        sleep_ms(500);\n\n        if (dir == 0) continue;\n\n        if (pos == L1) {\n            if (golpe_L) {\n                dir = 1;\n                golpe_L = false;\n            } else {\n                reiniciar_juego(LED_P2);\n                continue;\n            }\n        } else if (pos == L5) {\n            if (golpe_R) {\n                dir = -1;\n                golpe_R = false;\n            } else {\n                reiniciar_juego(LED_P1);\n                continue;\n            }\n        }\n\n        if (pos == L2 &amp;&amp; golpe_L) {\n            dir = 1;\n            golpe_L = false;\n        } else if (pos == L4 &amp;&amp; golpe_R) {\n            dir = -1;\n            golpe_R = false;\n        }\n\n        pos += dir;\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p> <p>Video en youtube</p>"}]}